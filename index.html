<!DOCTYPE html>
<html>
  <head>
    <title>Testing Middleware</title>
  </head>
  <body>
    <h1 id="server-title"></h1>

    <p id="server-description"></p>

    <p>
      Here it shows the timing difference between vulnerable and secure payment
      middleware implementations. The vulnerable version streams response
      content before settlement completes, while the secure version buffers
      content until settlement verification is complete.
    </p>

    <button onclick="testEndpoint('/weather')">Test /weather</button>
    <button onclick="testEndpoint('/stream')">Test /stream</button>

    <h3>Response:</h3>
    <pre id="result"></pre>

    <h3>Timing Analysis:</h3>
    <pre id="timing"></pre>

    <script>
      const currentPort = window.location.port;
      const isVulnerable = currentPort === "8000";

      const serverType = isVulnerable ? "VULNERABLE" : "SECURE";
      const description = isVulnerable
        ? "THIS IS THE VULNERABLE MIDDLEWARE"
        : "THIS IS THE SECURE MIDDLEWARE";

      document.getElementById(
        "server-title"
      ).textContent = `${serverType} Middleware`;
      document.getElementById("server-description").textContent = description;

      async function testEndpoint(endpoint) {
        const result = document.getElementById("result");
        const timing = document.getElementById("timing");
        result.textContent = "Testing...";
        timing.textContent = "";

        const start = Date.now();
        let firstByteTime = null;
        let chunks = [];

        try {
          const response = await fetch(endpoint);

          const reader = response.body.getReader();
          const decoder = new TextDecoder();

          while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            if (firstByteTime === null) {
              firstByteTime = Date.now() - start;
              timing.textContent = `First byte received: ${firstByteTime}ms\n`;
            }

            chunks.push(decoder.decode(value, { stream: true }));
            timing.textContent += `Chunk received at ${Date.now() - start}ms\n`;
          }

          const totalTime = Date.now() - start;
          const text = chunks.join("");

          // console.log(response);
          // console.log(response.body);
          


          result.textContent = `Status Code: ${response.status}\n`;
          result.textContent += `Total Time: ${totalTime}ms\n`;
          result.textContent += `\nResponse Body:\n${text || "(empty)"}`;

          result.textContent += `\n\nFull Raw Response:\n${JSON.stringify(
            response,
            null,
            2
          )}`;

          // read the response stream please .. the body is ReadableStream response.body
          result.textContent +=  `\n\nResponse Stream Chunks:\n${JSON.stringify(
            chunks,
            null,
            2
          )}`;


          timing.textContent += `\nFinal response at: ${totalTime}ms\n`;

          const hasEndpointData = text.includes("weather") || text.includes("chunk");
          const hasErrorMessage = text.includes("error") || text.includes("Payment Required");

          if (response.status === 402 && hasEndpointData) {
            timing.textContent += `\nVULNERABILITY DETECTED: Received actual endpoint data with 402 status!\nThe middleware returned the original response with unconsumed body_iterator.\nProtected content was exposed even though settlement failed.`;
          } else if (response.status === 402 && hasErrorMessage) {
            timing.textContent += `\nSECURE: 402 response contains only error message, no endpoint data leaked.\nThe buffered response body was discarded and never sent to client.`;
          } else if (response.status === 200 && chunks.length > 0) {
            timing.textContent += `\nPayment succeeded: Content delivered at ${firstByteTime}ms`;
          }
        } catch (error) {
          result.textContent = `Error: ${error.message}`;
        }
      }
    </script>
  </body>
</html>

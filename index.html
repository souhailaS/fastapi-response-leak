<!DOCTYPE html>
<html>
  <head>
    <title>Testing Middleware</title>
  </head>
  <body>
    <h1 id="server-title"></h1>

    <p id="server-description"></p>

    <p>
      Here it shows the timing difference between vulnerable and secure payment
      middleware implementations. The vulnerable version streams response
      content before settlement completes, while the secure version buffers
      content until settlement verification is complete.
    </p>

    <button onclick="testEndpoint('/weather')">Test /weather</button>
    <button onclick="testEndpoint('/stream')">Test /stream</button>

    <h3>Response:</h3>
    <pre id="result"></pre>

    <h3>Timing Analysis:</h3>
    <pre id="timing"></pre>

    <script>
      const currentPort = window.location.port;
      const isVulnerable = currentPort === "8000";

      const serverType = isVulnerable ? "VULNERABLE" : "SECURE";
      const description = isVulnerable
        ? "THIS IS THE VULNERABLE MIDDLEWARE"
        : "THIS IS THE SECURE MIDDLEWARE";

      document.getElementById(
        "server-title"
      ).textContent = `${serverType} Middleware`;
      document.getElementById("server-description").textContent = description;

      async function testEndpoint(endpoint) {
        const result = document.getElementById("result");
        const timing = document.getElementById("timing");
        result.textContent = "Testing...";
        timing.textContent = "";

        const start = Date.now();
        let firstByteTime = null;
        let chunks = [];

        try {
          const response = await fetch(endpoint);

          const reader = response.body.getReader();
          const decoder = new TextDecoder();

          while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            if (firstByteTime === null) {
              firstByteTime = Date.now() - start;
              timing.textContent = `First byte received: ${firstByteTime}ms\n`;
            }

            chunks.push(decoder.decode(value, { stream: true }));
            timing.textContent += `Chunk received at ${Date.now() - start}ms\n`;
          }

          const totalTime = Date.now() - start;
          const text = chunks.join("");

          // console.log(response);
          // console.log(response.body);
          


          result.textContent = `Status Code: ${response.status}\n`;
          result.textContent += `Total Time: ${totalTime}ms\n`;
          result.textContent += `\nResponse Body:\n${text || "(empty)"}`;

          result.textContent += `\n\nFull Raw Response:\n${JSON.stringify(
            response,
            null,
            2
          )}`;

          // read the response stream please .. the body is ReadableStream response.body
          result.textContent +=  `\n\nResponse Stream Chunks:\n${JSON.stringify(
            chunks,
            null,
            2
          )}`;


          timing.textContent += `\nFinal response at: ${totalTime}ms\n`;
          // just for logging purposes
          const SETTLEMENT_TIME = 500;

          if (response.status === 402 && firstByteTime && firstByteTime < SETTLEMENT_TIME) {
            timing.textContent += `\nVULNERABILITY DETECTED: Content streaming started at ${firstByteTime}ms BEFORE settlement completed (${SETTLEMENT_TIME}ms)!\nThe middleware sent response data before verifying payment settlement.`;
          } else if (response.status === 402 && chunks.length > 0) {
            timing.textContent += `\nSECURE: 402 response received at ${firstByteTime}ms AFTER settlement completed (${SETTLEMENT_TIME}ms).`;
          } else if (response.status === 402 && chunks.length === 0) {
            timing.textContent += `\nSECURE: No content leaked. Settlement failed and 402 returned without sending response data.`;
          } else if (chunks.length > 0) {
            timing.textContent += `\nContent streaming started at: ${firstByteTime}ms`;
          }
        } catch (error) {
          result.textContent = `Error: ${error.message}`;
        }
      }
    </script>
  </body>
</html>
